/*
 * Route Optimization
 *
 * With the Route Optimization service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.9
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.routeoptimization.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.routeoptimization.Model
{
    /// <summary>
    /// A driver is always assigned to a specific vehicle and may not always be available to operate it. To be precise, a driver can only operate the corresponding vehicle within given time intervals.
    /// </summary>
    [DataContract(Name = "Driver")]
    public partial class Driver : IEquatable<Driver>, IValidatableObject
    {

        /// <summary>
        /// Gets or Sets WorkingHoursPreset
        /// </summary>
        [DataMember(Name = "workingHoursPreset", EmitDefaultValue = true)]
        public WorkingHoursPreset? WorkingHoursPreset { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Driver" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Driver() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Driver" /> class.
        /// </summary>
        /// <param name="id">The unique ID of the driver. (required).</param>
        /// <param name="vehicleId">The ID of the driver&#39;s vehicle. This vehicle must not be referenced by another driver. (required).</param>
        /// <param name="availabilities">Intervals during which the driver is available, each specified by two points in time - the beginning and the end of the interval. Each trip must lie completely within one of the intervals. The route start and trip start events must lie within one of the intervals. The intervals must have a gap of more than 1 second. Leaving this parameter empty means that the driver is always available..</param>
        /// <param name="workingHoursPreset">workingHoursPreset.</param>
        /// <param name="breakRule">breakRule.</param>
        /// <param name="dailyRestRule">dailyRestRule.</param>
        /// <param name="workLogbook">workLogbook.</param>
        /// <param name="maximumDrivingTime">The maximum driving time of the driver [s].   This includes the driving time before the start of the route (see **accumulatedDrivingTimeSinceLastDailyRest** in **workLogbook**). The maximum driving time is considered as infinite if it is not set. Currently, each driver must have the same value specified..</param>
        /// <param name="maximumTravelTime">The maximum travel time of the driver [s]. The travel time contains all waiting, service and driving times.  This includes the travel time before the start of the route (see **accumulatedTravelTimeSinceLastDailyRest** in **workLogbook**). The maximum travel time is considered as infinite if it is not set. Currently, each driver must have the same value specified..</param>
        public Driver(string id = default(string), string vehicleId = default(string), List<TimeInterval> availabilities = default(List<TimeInterval>), WorkingHoursPreset? workingHoursPreset = default(WorkingHoursPreset?), BreakRule breakRule = default(BreakRule), DailyRestRule dailyRestRule = default(DailyRestRule), WorkLogbook workLogbook = default(WorkLogbook), int? maximumDrivingTime = default(int?), int? maximumTravelTime = default(int?))
        {
            // to ensure "id" is required (not null)
            if (id == null) {
                throw new ArgumentNullException("id is a required property for Driver and cannot be null");
            }
            this.Id = id;
            // to ensure "vehicleId" is required (not null)
            if (vehicleId == null) {
                throw new ArgumentNullException("vehicleId is a required property for Driver and cannot be null");
            }
            this.VehicleId = vehicleId;
            this.Availabilities = availabilities;
            this.WorkingHoursPreset = workingHoursPreset;
            this.BreakRule = breakRule;
            this.DailyRestRule = dailyRestRule;
            this.WorkLogbook = workLogbook;
            this.MaximumDrivingTime = maximumDrivingTime;
            this.MaximumTravelTime = maximumTravelTime;
        }

        /// <summary>
        /// The unique ID of the driver.
        /// </summary>
        /// <value>The unique ID of the driver.</value>
        [DataMember(Name = "id", IsRequired = true, EmitDefaultValue = false)]
        public string Id { get; set; }

        /// <summary>
        /// The ID of the driver&#39;s vehicle. This vehicle must not be referenced by another driver.
        /// </summary>
        /// <value>The ID of the driver&#39;s vehicle. This vehicle must not be referenced by another driver.</value>
        [DataMember(Name = "vehicleId", IsRequired = true, EmitDefaultValue = false)]
        public string VehicleId { get; set; }

        /// <summary>
        /// Intervals during which the driver is available, each specified by two points in time - the beginning and the end of the interval. Each trip must lie completely within one of the intervals. The route start and trip start events must lie within one of the intervals. The intervals must have a gap of more than 1 second. Leaving this parameter empty means that the driver is always available.
        /// </summary>
        /// <value>Intervals during which the driver is available, each specified by two points in time - the beginning and the end of the interval. Each trip must lie completely within one of the intervals. The route start and trip start events must lie within one of the intervals. The intervals must have a gap of more than 1 second. Leaving this parameter empty means that the driver is always available.</value>
        [DataMember(Name = "availabilities", EmitDefaultValue = false)]
        public List<TimeInterval> Availabilities { get; set; }

        /// <summary>
        /// Gets or Sets BreakRule
        /// </summary>
        [DataMember(Name = "breakRule", EmitDefaultValue = false)]
        public BreakRule BreakRule { get; set; }

        /// <summary>
        /// Gets or Sets DailyRestRule
        /// </summary>
        [DataMember(Name = "dailyRestRule", EmitDefaultValue = false)]
        public DailyRestRule DailyRestRule { get; set; }

        /// <summary>
        /// Gets or Sets WorkLogbook
        /// </summary>
        [DataMember(Name = "workLogbook", EmitDefaultValue = false)]
        public WorkLogbook WorkLogbook { get; set; }

        /// <summary>
        /// The maximum driving time of the driver [s].   This includes the driving time before the start of the route (see **accumulatedDrivingTimeSinceLastDailyRest** in **workLogbook**). The maximum driving time is considered as infinite if it is not set. Currently, each driver must have the same value specified.
        /// </summary>
        /// <value>The maximum driving time of the driver [s].   This includes the driving time before the start of the route (see **accumulatedDrivingTimeSinceLastDailyRest** in **workLogbook**). The maximum driving time is considered as infinite if it is not set. Currently, each driver must have the same value specified.</value>
        [DataMember(Name = "maximumDrivingTime", EmitDefaultValue = true)]
        public int? MaximumDrivingTime { get; set; }

        /// <summary>
        /// The maximum travel time of the driver [s]. The travel time contains all waiting, service and driving times.  This includes the travel time before the start of the route (see **accumulatedTravelTimeSinceLastDailyRest** in **workLogbook**). The maximum travel time is considered as infinite if it is not set. Currently, each driver must have the same value specified.
        /// </summary>
        /// <value>The maximum travel time of the driver [s]. The travel time contains all waiting, service and driving times.  This includes the travel time before the start of the route (see **accumulatedTravelTimeSinceLastDailyRest** in **workLogbook**). The maximum travel time is considered as infinite if it is not set. Currently, each driver must have the same value specified.</value>
        [DataMember(Name = "maximumTravelTime", EmitDefaultValue = true)]
        public int? MaximumTravelTime { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Driver {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  VehicleId: ").Append(VehicleId).Append("\n");
            sb.Append("  Availabilities: ").Append(Availabilities).Append("\n");
            sb.Append("  WorkingHoursPreset: ").Append(WorkingHoursPreset).Append("\n");
            sb.Append("  BreakRule: ").Append(BreakRule).Append("\n");
            sb.Append("  DailyRestRule: ").Append(DailyRestRule).Append("\n");
            sb.Append("  WorkLogbook: ").Append(WorkLogbook).Append("\n");
            sb.Append("  MaximumDrivingTime: ").Append(MaximumDrivingTime).Append("\n");
            sb.Append("  MaximumTravelTime: ").Append(MaximumTravelTime).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Driver);
        }

        /// <summary>
        /// Returns true if Driver instances are equal
        /// </summary>
        /// <param name="input">Instance of Driver to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Driver input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.VehicleId == input.VehicleId ||
                    (this.VehicleId != null &&
                    this.VehicleId.Equals(input.VehicleId))
                ) && 
                (
                    this.Availabilities == input.Availabilities ||
                    this.Availabilities != null &&
                    input.Availabilities != null &&
                    this.Availabilities.SequenceEqual(input.Availabilities)
                ) && 
                (
                    this.WorkingHoursPreset == input.WorkingHoursPreset ||
                    this.WorkingHoursPreset.Equals(input.WorkingHoursPreset)
                ) && 
                (
                    this.BreakRule == input.BreakRule ||
                    (this.BreakRule != null &&
                    this.BreakRule.Equals(input.BreakRule))
                ) && 
                (
                    this.DailyRestRule == input.DailyRestRule ||
                    (this.DailyRestRule != null &&
                    this.DailyRestRule.Equals(input.DailyRestRule))
                ) && 
                (
                    this.WorkLogbook == input.WorkLogbook ||
                    (this.WorkLogbook != null &&
                    this.WorkLogbook.Equals(input.WorkLogbook))
                ) && 
                (
                    this.MaximumDrivingTime == input.MaximumDrivingTime ||
                    (this.MaximumDrivingTime != null &&
                    this.MaximumDrivingTime.Equals(input.MaximumDrivingTime))
                ) && 
                (
                    this.MaximumTravelTime == input.MaximumTravelTime ||
                    (this.MaximumTravelTime != null &&
                    this.MaximumTravelTime.Equals(input.MaximumTravelTime))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Id != null)
                {
                    hashCode = (hashCode * 59) + this.Id.GetHashCode();
                }
                if (this.VehicleId != null)
                {
                    hashCode = (hashCode * 59) + this.VehicleId.GetHashCode();
                }
                if (this.Availabilities != null)
                {
                    hashCode = (hashCode * 59) + this.Availabilities.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.WorkingHoursPreset.GetHashCode();
                if (this.BreakRule != null)
                {
                    hashCode = (hashCode * 59) + this.BreakRule.GetHashCode();
                }
                if (this.DailyRestRule != null)
                {
                    hashCode = (hashCode * 59) + this.DailyRestRule.GetHashCode();
                }
                if (this.WorkLogbook != null)
                {
                    hashCode = (hashCode * 59) + this.WorkLogbook.GetHashCode();
                }
                if (this.MaximumDrivingTime != null)
                {
                    hashCode = (hashCode * 59) + this.MaximumDrivingTime.GetHashCode();
                }
                if (this.MaximumTravelTime != null)
                {
                    hashCode = (hashCode * 59) + this.MaximumTravelTime.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            // Id (string) pattern
            Regex regexId = new Regex(@".*[^ ].*", RegexOptions.CultureInvariant);
            if (false == regexId.Match(this.Id).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Id, must match a pattern of " + regexId, new [] { "Id" });
            }

            // VehicleId (string) pattern
            Regex regexVehicleId = new Regex(@".*[^ ].*", RegexOptions.CultureInvariant);
            if (false == regexVehicleId.Match(this.VehicleId).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for VehicleId, must match a pattern of " + regexVehicleId, new [] { "VehicleId" });
            }

            // MaximumDrivingTime (int?) minimum
            if (this.MaximumDrivingTime < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for MaximumDrivingTime, must be a value greater than or equal to 1.", new [] { "MaximumDrivingTime" });
            }

            // MaximumTravelTime (int?) minimum
            if (this.MaximumTravelTime < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for MaximumTravelTime, must be a value greater than or equal to 1.", new [] { "MaximumTravelTime" });
            }

            yield break;
        }
    }

}
