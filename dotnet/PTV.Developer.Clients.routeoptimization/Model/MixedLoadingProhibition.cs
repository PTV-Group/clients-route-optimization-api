/*
 * Route Optimization
 *
 * With the Route Optimization service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.7
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.routeoptimization.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.routeoptimization.Model
{
    /// <summary>
    /// There may be some transports that shall not be mixed with some other transports on one trip. For instance, it may be prohibited to load certain dangerous goods together on the same trip, such as flammable solids on the one hand and explosive substances on the other hand. A mixed loading prohibition is a pair of two conflicting load categories that prohibits transports with these load categories to be mixed on the same trip. The load category can be specified for every transport. For a vehicle, there is a flag that lets the vehicle ignore this restriction.  See [here](./Concepts/Mixed%20Loading%20Prohibitions.htm) for more information.
    /// </summary>
    [DataContract(Name = "MixedLoadingProhibition")]
    public partial class MixedLoadingProhibition : IEquatable<MixedLoadingProhibition>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MixedLoadingProhibition" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected MixedLoadingProhibition() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MixedLoadingProhibition" /> class.
        /// </summary>
        /// <param name="conflictingLoadCategory1">A transport with this load category is not allowed to be on the same trip as a transport with load category conflictingLoadCategory2. The load category can be any string but it must not be empty and not the same as conflictingLoadCategory2. (required).</param>
        /// <param name="conflictingLoadCategory2">A transport with this load category is not allowed to be on the same trip as a transport with load category conflictingLoadCategory1. The load category can be any string but it must not be empty and not the same as conflictingLoadCategory1. (required).</param>
        public MixedLoadingProhibition(string conflictingLoadCategory1 = default(string), string conflictingLoadCategory2 = default(string))
        {
            // to ensure "conflictingLoadCategory1" is required (not null)
            if (conflictingLoadCategory1 == null) {
                throw new ArgumentNullException("conflictingLoadCategory1 is a required property for MixedLoadingProhibition and cannot be null");
            }
            this.ConflictingLoadCategory1 = conflictingLoadCategory1;
            // to ensure "conflictingLoadCategory2" is required (not null)
            if (conflictingLoadCategory2 == null) {
                throw new ArgumentNullException("conflictingLoadCategory2 is a required property for MixedLoadingProhibition and cannot be null");
            }
            this.ConflictingLoadCategory2 = conflictingLoadCategory2;
        }

        /// <summary>
        /// A transport with this load category is not allowed to be on the same trip as a transport with load category conflictingLoadCategory2. The load category can be any string but it must not be empty and not the same as conflictingLoadCategory2.
        /// </summary>
        /// <value>A transport with this load category is not allowed to be on the same trip as a transport with load category conflictingLoadCategory2. The load category can be any string but it must not be empty and not the same as conflictingLoadCategory2.</value>
        [DataMember(Name = "conflictingLoadCategory1", IsRequired = true, EmitDefaultValue = false)]
        public string ConflictingLoadCategory1 { get; set; }

        /// <summary>
        /// A transport with this load category is not allowed to be on the same trip as a transport with load category conflictingLoadCategory1. The load category can be any string but it must not be empty and not the same as conflictingLoadCategory1.
        /// </summary>
        /// <value>A transport with this load category is not allowed to be on the same trip as a transport with load category conflictingLoadCategory1. The load category can be any string but it must not be empty and not the same as conflictingLoadCategory1.</value>
        [DataMember(Name = "conflictingLoadCategory2", IsRequired = true, EmitDefaultValue = false)]
        public string ConflictingLoadCategory2 { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class MixedLoadingProhibition {\n");
            sb.Append("  ConflictingLoadCategory1: ").Append(ConflictingLoadCategory1).Append("\n");
            sb.Append("  ConflictingLoadCategory2: ").Append(ConflictingLoadCategory2).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MixedLoadingProhibition);
        }

        /// <summary>
        /// Returns true if MixedLoadingProhibition instances are equal
        /// </summary>
        /// <param name="input">Instance of MixedLoadingProhibition to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MixedLoadingProhibition input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.ConflictingLoadCategory1 == input.ConflictingLoadCategory1 ||
                    (this.ConflictingLoadCategory1 != null &&
                    this.ConflictingLoadCategory1.Equals(input.ConflictingLoadCategory1))
                ) && 
                (
                    this.ConflictingLoadCategory2 == input.ConflictingLoadCategory2 ||
                    (this.ConflictingLoadCategory2 != null &&
                    this.ConflictingLoadCategory2.Equals(input.ConflictingLoadCategory2))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ConflictingLoadCategory1 != null)
                {
                    hashCode = (hashCode * 59) + this.ConflictingLoadCategory1.GetHashCode();
                }
                if (this.ConflictingLoadCategory2 != null)
                {
                    hashCode = (hashCode * 59) + this.ConflictingLoadCategory2.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            // ConflictingLoadCategory1 (string) pattern
            Regex regexConflictingLoadCategory1 = new Regex(@".*[^ ].*", RegexOptions.CultureInvariant);
            if (false == regexConflictingLoadCategory1.Match(this.ConflictingLoadCategory1).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ConflictingLoadCategory1, must match a pattern of " + regexConflictingLoadCategory1, new [] { "ConflictingLoadCategory1" });
            }

            // ConflictingLoadCategory2 (string) pattern
            Regex regexConflictingLoadCategory2 = new Regex(@".*[^ ].*", RegexOptions.CultureInvariant);
            if (false == regexConflictingLoadCategory2.Match(this.ConflictingLoadCategory2).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ConflictingLoadCategory2, must match a pattern of " + regexConflictingLoadCategory2, new [] { "ConflictingLoadCategory2" });
            }

            yield break;
        }
    }

}
