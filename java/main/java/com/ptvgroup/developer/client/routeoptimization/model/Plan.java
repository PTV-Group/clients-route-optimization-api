/*
 * Route Optimization
 * With the Route Optimization service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.8
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ptvgroup.developer.client.routeoptimization.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.ptvgroup.developer.client.routeoptimization.model.Driver;
import com.ptvgroup.developer.client.routeoptimization.model.Location;
import com.ptvgroup.developer.client.routeoptimization.model.PlanningRestrictions;
import com.ptvgroup.developer.client.routeoptimization.model.Route;
import com.ptvgroup.developer.client.routeoptimization.model.TimeInterval;
import com.ptvgroup.developer.client.routeoptimization.model.Transport;
import com.ptvgroup.developer.client.routeoptimization.model.Vehicle;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.openapitools.jackson.nullable.JsonNullable;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.openapitools.jackson.nullable.JsonNullable;
import java.util.NoSuchElementException;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * The request object for the service method &#39;createPlan&#39; and the result of the service method &#39;getPlan&#39;.
 */
@ApiModel(description = "The request object for the service method 'createPlan' and the result of the service method 'getPlan'.")
@JsonPropertyOrder({
  Plan.JSON_PROPERTY_ID,
  Plan.JSON_PROPERTY_DESCRIPTION,
  Plan.JSON_PROPERTY_LOCATIONS,
  Plan.JSON_PROPERTY_VEHICLES,
  Plan.JSON_PROPERTY_DRIVERS,
  Plan.JSON_PROPERTY_TRANSPORTS,
  Plan.JSON_PROPERTY_PLANNING_HORIZON,
  Plan.JSON_PROPERTY_RESTRICTIONS,
  Plan.JSON_PROPERTY_ROUTES,
  Plan.JSON_PROPERTY_UNPLANNED_VEHICLE_IDS,
  Plan.JSON_PROPERTY_UNPLANNED_TRANSPORT_IDS
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-02-14T18:00:22.453541900+01:00[Europe/Berlin]")
public class Plan {
  public static final String JSON_PROPERTY_ID = "id";
  private UUID id;

  public static final String JSON_PROPERTY_DESCRIPTION = "description";
  private String description;

  public static final String JSON_PROPERTY_LOCATIONS = "locations";
  private List<Location> locations = new ArrayList<>();

  public static final String JSON_PROPERTY_VEHICLES = "vehicles";
  private List<Vehicle> vehicles = new ArrayList<>();

  public static final String JSON_PROPERTY_DRIVERS = "drivers";
  private List<Driver> drivers = null;

  public static final String JSON_PROPERTY_TRANSPORTS = "transports";
  private List<Transport> transports = new ArrayList<>();

  public static final String JSON_PROPERTY_PLANNING_HORIZON = "planningHorizon";
  private JsonNullable<TimeInterval> planningHorizon = JsonNullable.<TimeInterval>undefined();

  public static final String JSON_PROPERTY_RESTRICTIONS = "restrictions";
  private PlanningRestrictions restrictions;

  public static final String JSON_PROPERTY_ROUTES = "routes";
  private List<Route> routes = null;

  public static final String JSON_PROPERTY_UNPLANNED_VEHICLE_IDS = "unplannedVehicleIds";
  private List<String> unplannedVehicleIds = null;

  public static final String JSON_PROPERTY_UNPLANNED_TRANSPORT_IDS = "unplannedTransportIds";
  private List<String> unplannedTransportIds = null;

  public Plan() { 
  }

  @JsonCreator
  public Plan(
    @JsonProperty(JSON_PROPERTY_ID) UUID id, 
    @JsonProperty(JSON_PROPERTY_UNPLANNED_VEHICLE_IDS) List<String> unplannedVehicleIds, 
    @JsonProperty(JSON_PROPERTY_UNPLANNED_TRANSPORT_IDS) List<String> unplannedTransportIds
  ) {
  this();
    this.id = id;
    this.unplannedVehicleIds = unplannedVehicleIds;
    this.unplannedTransportIds = unplannedTransportIds;
  }

   /**
   * The ID of the plan. It is generated when the plan is created.
   * @return id
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The ID of the plan. It is generated when the plan is created.")
  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public UUID getId() {
    return id;
  }




  public Plan description(String description) {
    this.description = description;
    return this;
  }

   /**
   * A description of the plan.
   * @return description
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A description of the plan.")
  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getDescription() {
    return description;
  }


  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDescription(String description) {
    this.description = description;
  }


  public Plan locations(List<Location> locations) {
    this.locations = locations;
    return this;
  }

  public Plan addLocationsItem(Location locationsItem) {
    this.locations.add(locationsItem);
    return this;
  }

   /**
   * A list of depot or customer locations that may be referenced by vehicles, transports and stops. A location is either a depot location or a customer location. Depot locations act as trip delimiters. Each location must be referenced by another object. If a request contains a location not referenced by any other object, the request will be rejected.
   * @return locations
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "A list of depot or customer locations that may be referenced by vehicles, transports and stops. A location is either a depot location or a customer location. Depot locations act as trip delimiters. Each location must be referenced by another object. If a request contains a location not referenced by any other object, the request will be rejected.")
  @JsonProperty(JSON_PROPERTY_LOCATIONS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<Location> getLocations() {
    return locations;
  }


  @JsonProperty(JSON_PROPERTY_LOCATIONS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLocations(List<Location> locations) {
    this.locations = locations;
  }


  public Plan vehicles(List<Vehicle> vehicles) {
    this.vehicles = vehicles;
    return this;
  }

  public Plan addVehiclesItem(Vehicle vehiclesItem) {
    this.vehicles.add(vehiclesItem);
    return this;
  }

   /**
   * A list of vehicles that can be used to transport goods.
   * @return vehicles
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "A list of vehicles that can be used to transport goods.")
  @JsonProperty(JSON_PROPERTY_VEHICLES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<Vehicle> getVehicles() {
    return vehicles;
  }


  @JsonProperty(JSON_PROPERTY_VEHICLES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setVehicles(List<Vehicle> vehicles) {
    this.vehicles = vehicles;
  }


  public Plan drivers(List<Driver> drivers) {
    this.drivers = drivers;
    return this;
  }

  public Plan addDriversItem(Driver driversItem) {
    if (this.drivers == null) {
      this.drivers = new ArrayList<>();
    }
    this.drivers.add(driversItem);
    return this;
  }

   /**
   * A list of drivers. A driver is always assigned to a specific vehicle. In turn, a vehicle can but does not need to have a driver assigned to it. If a driver is assigned to a vehicle, the driver&#39;s restrictions apply, such as its limited availability. If no drivers are specified, the drivers of all vehicles are always available.
   * @return drivers
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of drivers. A driver is always assigned to a specific vehicle. In turn, a vehicle can but does not need to have a driver assigned to it. If a driver is assigned to a vehicle, the driver's restrictions apply, such as its limited availability. If no drivers are specified, the drivers of all vehicles are always available.")
  @JsonProperty(JSON_PROPERTY_DRIVERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<Driver> getDrivers() {
    return drivers;
  }


  @JsonProperty(JSON_PROPERTY_DRIVERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDrivers(List<Driver> drivers) {
    this.drivers = drivers;
  }


  public Plan transports(List<Transport> transports) {
    this.transports = transports;
    return this;
  }

  public Plan addTransportsItem(Transport transportsItem) {
    this.transports.add(transportsItem);
    return this;
  }

   /**
   * A list of transports, that is, orders to transport goods from one location to another location. Depending on your subscription, a more restrictive value for maximum number of transport may apply. Check request limits of your subscription.
   * @return transports
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "A list of transports, that is, orders to transport goods from one location to another location. Depending on your subscription, a more restrictive value for maximum number of transport may apply. Check request limits of your subscription.")
  @JsonProperty(JSON_PROPERTY_TRANSPORTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<Transport> getTransports() {
    return transports;
  }


  @JsonProperty(JSON_PROPERTY_TRANSPORTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTransports(List<Transport> transports) {
    this.transports = transports;
  }


  public Plan planningHorizon(TimeInterval planningHorizon) {
    this.planningHorizon = JsonNullable.<TimeInterval>of(planningHorizon);
    return this;
  }

   /**
   * The planning horizon for the plan, described by start and end date and time. All routes have to start and end within this planning horizon. All opening intervals outside of this planning horizon are not considered by the algorithm. If specified, the planning horizon is restricted to a maximum duration of two weeks. If not specified, the planning horizon is infinite. If no other time interval is specified within this plan, the planning horizon is required.
   * @return planningHorizon
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The planning horizon for the plan, described by start and end date and time. All routes have to start and end within this planning horizon. All opening intervals outside of this planning horizon are not considered by the algorithm. If specified, the planning horizon is restricted to a maximum duration of two weeks. If not specified, the planning horizon is infinite. If no other time interval is specified within this plan, the planning horizon is required.")
  @JsonIgnore

  public TimeInterval getPlanningHorizon() {
        return planningHorizon.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_PLANNING_HORIZON)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<TimeInterval> getPlanningHorizon_JsonNullable() {
    return planningHorizon;
  }
  
  @JsonProperty(JSON_PROPERTY_PLANNING_HORIZON)
  public void setPlanningHorizon_JsonNullable(JsonNullable<TimeInterval> planningHorizon) {
    this.planningHorizon = planningHorizon;
  }

  public void setPlanningHorizon(TimeInterval planningHorizon) {
    this.planningHorizon = JsonNullable.<TimeInterval>of(planningHorizon);
  }


  public Plan restrictions(PlanningRestrictions restrictions) {
    this.restrictions = restrictions;
    return this;
  }

   /**
   * Get restrictions
   * @return restrictions
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_RESTRICTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public PlanningRestrictions getRestrictions() {
    return restrictions;
  }


  @JsonProperty(JSON_PROPERTY_RESTRICTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRestrictions(PlanningRestrictions restrictions) {
    this.restrictions = restrictions;
  }


  public Plan routes(List<Route> routes) {
    this.routes = routes;
    return this;
  }

  public Plan addRoutesItem(Route routesItem) {
    if (this.routes == null) {
      this.routes = new ArrayList<>();
    }
    this.routes.add(routesItem);
    return this;
  }

   /**
   * A list of routes. A route contains a sequence of stops. It specifies where and in which order goods are to be picked up or delivered. Each stop can be assigned to a trip. A route is subdivided into trips. Each route has at least one trip and a trip consists of at least two stops. At the beginning and end of each trip the vehicle does not carry any load. A trip starts at the vehicle start location or at a depot location, and ends at the vehicle end location or at a depot location. If routes are already given in input they are considered during planning. Transports which are already planned in an input route will also remain planned in the output routes. This might lead to violations of the routes.   See [here](./concepts/routes-and-trips) for more information.
   * @return routes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of routes. A route contains a sequence of stops. It specifies where and in which order goods are to be picked up or delivered. Each stop can be assigned to a trip. A route is subdivided into trips. Each route has at least one trip and a trip consists of at least two stops. At the beginning and end of each trip the vehicle does not carry any load. A trip starts at the vehicle start location or at a depot location, and ends at the vehicle end location or at a depot location. If routes are already given in input they are considered during planning. Transports which are already planned in an input route will also remain planned in the output routes. This might lead to violations of the routes.   See [here](./concepts/routes-and-trips) for more information.")
  @JsonProperty(JSON_PROPERTY_ROUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<Route> getRoutes() {
    return routes;
  }


  @JsonProperty(JSON_PROPERTY_ROUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRoutes(List<Route> routes) {
    this.routes = routes;
  }


   /**
   * Returns the vehicle IDs that are not used in the response of an optimization operation. These vehicles are not assigned to any route.
   * @return unplannedVehicleIds
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Returns the vehicle IDs that are not used in the response of an optimization operation. These vehicles are not assigned to any route.")
  @JsonProperty(JSON_PROPERTY_UNPLANNED_VEHICLE_IDS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<String> getUnplannedVehicleIds() {
    return unplannedVehicleIds;
  }




   /**
   * Returns the transport IDs that could not be planned in the response of an optimization operation. These transports are not part of the routes.
   * @return unplannedTransportIds
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Returns the transport IDs that could not be planned in the response of an optimization operation. These transports are not part of the routes.")
  @JsonProperty(JSON_PROPERTY_UNPLANNED_TRANSPORT_IDS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<String> getUnplannedTransportIds() {
    return unplannedTransportIds;
  }




  /**
   * Return true if this Plan object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Plan plan = (Plan) o;
    return Objects.equals(this.id, plan.id) &&
        Objects.equals(this.description, plan.description) &&
        Objects.equals(this.locations, plan.locations) &&
        Objects.equals(this.vehicles, plan.vehicles) &&
        Objects.equals(this.drivers, plan.drivers) &&
        Objects.equals(this.transports, plan.transports) &&
        equalsNullable(this.planningHorizon, plan.planningHorizon) &&
        Objects.equals(this.restrictions, plan.restrictions) &&
        Objects.equals(this.routes, plan.routes) &&
        Objects.equals(this.unplannedVehicleIds, plan.unplannedVehicleIds) &&
        Objects.equals(this.unplannedTransportIds, plan.unplannedTransportIds);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, description, locations, vehicles, drivers, transports, hashCodeNullable(planningHorizon), restrictions, routes, unplannedVehicleIds, unplannedTransportIds);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Plan {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    locations: ").append(toIndentedString(locations)).append("\n");
    sb.append("    vehicles: ").append(toIndentedString(vehicles)).append("\n");
    sb.append("    drivers: ").append(toIndentedString(drivers)).append("\n");
    sb.append("    transports: ").append(toIndentedString(transports)).append("\n");
    sb.append("    planningHorizon: ").append(toIndentedString(planningHorizon)).append("\n");
    sb.append("    restrictions: ").append(toIndentedString(restrictions)).append("\n");
    sb.append("    routes: ").append(toIndentedString(routes)).append("\n");
    sb.append("    unplannedVehicleIds: ").append(toIndentedString(unplannedVehicleIds)).append("\n");
    sb.append("    unplannedTransportIds: ").append(toIndentedString(unplannedTransportIds)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

